# 领域驱动设计

****领域驱动设计(Domain Driven Design)****是一种软件设计方法，已经存在了近20年，在过去十年中，随着微服务和相关技术的激增，受到了巨大的关注。DDD更注重软件开发的逻辑、语义和结构方面(倾向于业务端)，而不是应用规范的实现方式，虽然它也提供了几种良好的设计模式。DDD是处理复杂软件的理想方法，但对于小型、独立项目来说可能会很冗长。

### 什么是领域驱动设计

什么是领域？领域由三部分组成：领域里有用户，即涉众域；用户要实现某种业务价值，解决某些痛点或实现某种诉求，即问题域；面对业务价值，痛点和诉求，有对应的解决方案，这是解决方案域。什么是领域驱动设计？通俗地讲，针对特定业务，用户在面对业务问题时有对应的解决方案，这些问题与方案构成了领域知识，它包含流程、规则以及处理问题的方法，领域驱动设计就是围绕这些知识来设计系统。

以度假景点系统为例，度假景点系统所服务的用户有这几类：游客，运营，销售。解决 这几个核心问题：如何创建关联景点门票、酒店房型等商品组合，如何进行价格规则计算、什么时候进行售卖，订单如何扣减和支付。解决方案： 通过统一定义 product，里面涉及不同的景点门票和酒店房型的打包组合，同时定义不同的优惠方式，比如会员折扣，积分折扣等，构建时间售卖规则，构建订单流转流程，从订单、支付、扣减库存到发送邮件。

贫血模型

在领域模型中：只包含数据结构（字段、属性），没有任何业务逻辑的方法。叫做贫血模型。

充血模型

在贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。

**为什么选择 DDD**

基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应的，基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。

领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。

通过前期定义好领域知识，限定好上下文边界，从而可以形成高内聚，低耦合的业务单元，同时在同一个服务中，定义很好不同聚合的边界，使用领域模型，可以更好的在上层进行编排复用。

DDD 的核心诉求就是将业务架构映射到系统架构上，在响应业务变化调整业务架构时，也随之变化系统架构。

### 建立领域通用语言

为了实践不同领域之间的交互关系，我们可以看一下现实生活中KFC小程序购买套餐的场景

![Image.png](%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.assets/Image.png)

![Image.png](%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.assets/Image%20(2).png)

战略建模

User case

我将根据不同的角色出发，列出每个角色可能会涉及到的所有use case，然后罗列出每个use case可能会涵盖到的功能域，比如商品，订单，支付，库存等，从而识别出业务中的领域

User 🙎‍♂

选择商品加入购物车

用户可以浏览所有的商品，这里的商品可以是套餐，例如全家桶，小食拼盘等，也可以是单独种类的商品，香辣鸡翅🍗等

- 修改购物车

当用户选择了一些商品后，可以在购物车里进行修改，选择购买的数量，或者删除某些商品

- 商品结算

当用户添加好购物车后，选择外送或者堂食，然后进行结算

- 下单支付
- 用户选择优惠助手中的商品添加进购物车

用户可能领取了一些优惠套餐，然后就可以在规定时间内进行购买

- 用户可以在优惠助手中选择满减优惠券，会员卡等进行折扣

#### 运营人员🧑🏻‍💻

- 配置商品

运营人员可以配置一个可售卖的商品，比如商品的基本信息，商品可供选择的最小粒度产品，售卖数量范围，售卖时间，产品的折扣信息（打折，指定价格，买一赠一，会员折扣），赠品，售卖地区

- 配置优惠助手

将一些优惠套餐放进优惠助手中，限制使用次数，使用时间，来进行促销

- 上架新产品
- 配置优惠券

用户在商品结算时，可以通过使用优惠券(买一赠一，折扣)等来进行打折

- 配置产品库存

根据每天的供货量，配置每件产品的库存

#### 系统⚙️

- 更新库存

当用户每次购买商品中的产品后，需要进行库存的更新，防止系统库存超卖等现象，与此同时，当用户在下单某些商品时，因为库存不足，从而不能选择某些产品进行选购

- 在优惠助手中展示用户可使用的卡券

因为用户可能已经购买过有次数限制的优惠套餐，从而需要过滤掉用户已经使用过的卡券

- 列举可售卖商品

根据运营人员配置的商品售卖时间，来列举所有可售卖的商品，并且显示最小可购买价格

- 计算商品结算时的价格

上面所有use case，可以通过event storming的方式，将所有的场景列举出来

> 领域驱动设计的一个核心的原则是使用一种基于模型的语言。因为模型是软件满足领域的共同点，它很适合作为这种通用语言的构造基础

> 使用模型作为语言的核心骨架。要求团队在进行所有的交流是都使用一致的语言，在代码中也是这样。在共享知识和推敲模型时，团队会使用演讲、文字和图形。这儿需要确保团队使用的语言在所有的交流形式中看上去都是一致的。因为这个原因，这种语言被称为**通用语言(Ubiquitous Language)**

> **在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言。**也就是说，通用语言是团队统一的语言，不管你在团队中承担什么角色，在同一个领域的软件生命周期里都使用统一的语言进行交流。通用语言可以解决交流障碍这个问题，使领域专家和开发人员能够协同合作，从而确保业务需求的正确表达。

- Domain Event
   - 用户选择套餐，选择优惠券和地址进行下单
   - 某种产品库存已售罄
   - 上架新产品
- Command
   - 下单
   - 更新库存
   - 添加购物车
   - 上架新产品
- Policy
   - 选购某些套餐，其有固定购买数量
   - 优惠券使用时间范围，每天最多使用次数
- Aggregates
   - 产品
   - 订单
   - 优惠券
- Views
   - 不同类别的产品
   - 已有优惠券
   - 购物车
   - 已购订单

![spaces/KavC3w0wWUUBx4byjGaf/uploads/yCA57zIOgPyrANNdvlco/image.png](%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.assets/spaces/KavC3w0wWUUBx4byjGaf/uploads/yCA57zIOgPyrANNdvlco/image.png)

Core Domain： **核心领域**是一个组织赖以立足和区别于其他组织的根本所在。一个组织之所以能够成功，甚至能够存在，本质上依赖于其在核心领域中具备**卓越的能力**。正因为核心领域如此重要，它理应获得**最高的优先级**、**最多的资源投入**，以及**最优秀的开发人员**来实现。对于小型系统来说，可能只有一个核心领域；而在大型系统中，可能存在多个核心领域。

Support Domain： **支撑子域**是指那些虽然不是核心领域，但对于组织的成功依然不可或缺的业务领域。它不同于通用子域，因为它通常还需要结合组织的特定需求，进行一定程度的**定制或专门化开发**。在这种类型的子域中，组织**可以在已有的通用解决方案基础上出发**，通过**调整、扩展或集成**来满足自身业务的独特要求。

Generic Domain： **通用子域**是指那些在组织中没有独特性、但对整体系统运作仍然是**必要组成部分**的领域。这类子域的业务需求通常较为**标准化**，没有组织特有的复杂规则或流程。因此，组织可以通过采用**现成的第三方解决方案**（off-the-shelf software）来节省大量的开发时间和人力成本。一个典型的例子就是**用户身份管理系统（如登录、注册、权限控制）**，这类需求在不同组织之间大致相同，适合使用成熟的通用方案。

我们从整个小程序使用的生命周期开始先来识别所使用到的功能域：

- **商品配置**

一个商品在可以被售卖之前需要先在运营人员手里进行配置相关的售卖时间，不同种类的产品，可购买数量，产品的折扣信息，是否可以使用会员卡等；

- **优惠助手管理**

从小程序的界面上还可以看出，运营人员可以配置优惠助手中的优惠商品，来进行促销；

- **上架新商品**

运营人员可以通过**上架新商品**，来提供在不同时段可供售卖的商品

- **可售卖的商品和最小可购买价格**

在小程序上，最多的就是商品的展示了，那么在界面上需要显示**可售卖的商品和最小可购买价格**

- **优惠券管理**

运营人员需要提供一些满减活动的优惠券，独立于商品，可以在订单进行结算时提供折扣，并且对于优惠券的使用次数和时间有一定的限制，并且需要在优惠助手进行展示的时候进行校验

- **优惠券使用**

当用户将购物车里的商品进行结算时，可以选择自己拥有哪些优惠券，来进行折扣，那么在订单进行价格计算时需要考虑进去

- **购物车管理**

用户可以随时修改购物车里的商品

- **订单结算**

当用户最终选择好购物车里的内容后，就可以跳转到商品结算页面，然后选择优惠券，进行最后的订单结算

- **订单详情**

当用户支付完成时，可以查看其购买的订单详情

- **支付**

用户可以选择用微信支付，或者银行卡来进行支付

当罗列了这些存在的功能后，我们其实可以进行领域的识别，从不同利益人的角度出发，可以划分出大部分不同的领域，比如从用户出发，就是最核心的围绕订单相关领域；

从运营人员出发，就是商品配置，优惠助手管理，优惠券配置，而支付相关其实是依赖的第三方支付方式，可以作为支撑域来辅助订单领域；

在小程序下，购物车的管理大部分是客户端来完成，目前暂时不考虑在服务中引入购物车相关概念。

对于用户信息的展示，也需要相应的用户管理；

对于最小粒度的产品，还需要管理其库存和价格，考虑到不同上下文可能存在的交互复杂度，这里假设我们使用的是第三方的产品管理平台来管控实时库存和价格。

做好限界上下文：

在进行上下文划分之后，我们还需要进一步梳理上下文之间的关系。

> 康威（梅尔·康威）定律

> 任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。

康威定律告诉我们，系统结构应尽量的与组织结构保持一致。这里，我们认为团队结构（无论是内部组织还是团队间组织）就是组织结构，限界上下文就是系统的业务结构。因此，团队结构应该和限界上下文保持一致。

梳理清楚上下文之间的关系，从团队内部的关系来看，有如下好处：

1. 任务更好拆分，一个开发人员可以全身心的投入到相关的一个单独的上下文中；
2. 沟通更加顺畅，一个上下文可以明确自己对其他上下文的依赖关系，从而使得团队内开发直接更好的对接。

从团队间的关系来看，明确的上下文关系能够带来如下帮助：

1. 每个团队在它的上下文中能够更加明确自己领域内的概念，因为上下文是领域的解系统；
2. 对于限界上下文之间发生交互，团队与上下文的一致性，能够保证我们明确对接的团队和依赖的上下游。

在实际业务开发中，可以基于如下 3 个原则对限界上下文进行检验，并在适当时进行调整。

- 原则 1：正交原则。包括业务能力正交、领域知识正交、领域模型正交。
- 原则 2：单一抽象层次原则（SLAP），即永远确保在同一层次上进行抽象。
- 原则 3：奥卡姆剃刀原则。如无必要，勿增实体。

![Image.png](%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.assets/Image%20(3).png)

限界上下文之间的映射关系

- 合作关系（Partnership）：两个上下文紧密合作的关系，一荣俱荣，一损俱损。
- 共享内核（Shared Kernel）：两个上下文依赖部分共享的模型。
- 客户方-供应方开发（Customer-Supplier Development）：上下文之间有组织的上下游依赖。
- 遵奉者（Conformist）：下游上下文只能盲目依赖上游上下文。
- 防腐层（Anticorruption Layer）：一个上下文通过一些适配和转换与另一个上下文交互。
- 开放主机服务（Open Host Service）：定义一种协议来让其他上下文来对本上下文进行访问。
- 发布语言（Published Language）：通常与OHS一起使用，用于定义开放主机的协议。
- 大泥球（Big Ball of Mud）：混杂在一起的上下文关系，边界不清晰。
- 另谋他路（SeparateWay）：两个完全没有任何联系的上下文。

### **战术建模**

梳理清楚上下文之间的关系后，我们需要从战术层面上剖析上下文内部的组织关系。首先看下DDD中的一些定义。

实体

当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。

   例：最简单的，公安系统的身份信息录入，对于人的模拟，即认为是实体，因为每个人是独一无二的，且其具有唯一标识（如公安系统分发的身份证号码）。

值对象

当一个对象用于对事务进行描述而没有唯一标识时，它被称作值对象（Value Object）。

例：比如颜色信息，我们只需要知道{"name":"黑色"，"css":"#000000"}这样的值信息就能够满足要求了，这避免了我们对标识追踪带来的系统复杂性。

聚合根

在 DDD 中，实体和值对象是很基础的领域对象。实体一般对应业务对象，它具有业务属性和业务行为；而值对象主要是属性集合，对实体的状态和特征进行描述。但实体和值对象都只是个体化的对象，它们的行为表现出来的是个体的能力。

**领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。**

聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。

聚合在 DDD 分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。聚合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现。比如有的业务场景需要同一个聚合的 A 和 B 两个实体来共同完成，我们就可以将这段业务逻辑用领域服务来实现；而有的业务逻辑需要聚合 C 和聚合 D 中的两个服务共同完成，这时你就可以用应用服务来组合这两个服务。

商品活动上下文

![Image.png](%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.assets/Image%20(4).png)

### DDD 分层架构

![Image.png](%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.assets/Image%20(5).png)

领域建模的不停演进

假设新的库存系统，新的库存系统有更强大的库存管理功能，有对于不同时间段的价格和库存配置，之前的领域模型在计算商品是否可售和最小价格计算时，就将变的不同，那么可以在抽出一个领域服务，对于新的库存模型，定义新的值对象，同时对于商品的聚合根也是不变的，只需要建立新的领域服务来应对新的业务模型即可。

![Image.png](%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.assets/Image%20(6).png)

在服务设计时，你并不一定能完整预测有哪些下层服务会被多少个上层服务组装，因此领域层通常只提供一些原子服务，比如领域服务 a、b、c。但随着系统功能增强和外部接入越来越多，应用服务会不断丰富。有一天你会发现领域服务 b 和 c 同时多次被多个应用服务调用了，执行顺序也基本一致。这时你可以考虑将 b 和 c 合并，再将应用服务中 b、c 的功能下沉到领域层，演进为新的领域服务（b+c）。这样既减少了服务的数量，也减轻了上层服务组合和编排的复杂度

